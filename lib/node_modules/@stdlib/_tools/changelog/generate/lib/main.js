/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var dirname = require( 'path' ).dirname;
var substringAfter = require( '@stdlib/string/substring-after' );
var objectEntries = require( '@stdlib/utils/entries' );
var parseCommits = require( '@stdlib/_tools/changelog/parse-commits' );
var objectKeys = require( '@stdlib/utils/keys' );
var namespaces = require( '@stdlib/_tools/pkgs/namespaces' ).sync;
var contains = require( '@stdlib/assert/contains' );
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var replace = require( '@stdlib/string/replace' );
var groupBy = require( '@stdlib/utils/group-by' );
var filter = require( '@stdlib/array/base/filter' );
var format = require( '@stdlib/string/format' );
var formatContributors = require( './format_contributors.js' );
var releaseSummary = require( './release_summary.js' );
var formatCommits = require( './format_commits.js' );
var npmReleases = require( './npm_releases.js' );
var heading = require( './heading.js' );


// VARIABLES //

var STDLIB_NAMESPACE_PKGS = namespaces();
var STDLIB_REPO_NODE_PATH = 'https://github.com/stdlib-js/stdlib/tree/develop/lib/node_modules';
var RE_PACKAGE_SUBDIRS = /\/?(benchmark|bin|data|docs|docs|etc|examples|include|lib|scripts|src|test)\/?[\s\S]*$/;
var RE_MARKDOWN_HEADER = /(^#+)/gm;
var RE_EXTRANEOUS_NEWLINES = /\n{3,}/g;


// FUNCTIONS //

/**
* Changes all Markdown headers to be one level lower.
*
* @private
* @param {string} str - string to modify
* @returns {string} modified string
*
* @example
* var str = '## Foo\n\n### Bar\n';
* var out = decrementHeaders( str );
* // returns '### Foo\n\n#### Bar\n'
*/
function decrementHeaders( str ) {
	return replace( str, RE_MARKDOWN_HEADER, '$1#' );
}

/**
* Groups commits by subpackages.
*
* @private
* @param {ObjectArray} commits - commits
* @param {string} pkg - package name
* @returns {Object} grouped commits
*/
function groupBySubPackage( commits, pkg ) {
	var commit;
	var group;
	var out;
	var i;
	var j;

	out = {};
	for ( i = 0; i < commits.length; i++ ) {
		commit = commits[ i ];
		for ( j = 0; j < commit.files.length; j++ ) {
			if ( commit.files[ j ].indexOf( 'lib/node_modules/@stdlib/' ) !== -1 ) {
				group = dirname( commit.files[ j ] );
				group = substringAfter( group, ( pkg ) ? pkg + '/' : '@stdlib/' );
				group = replace( group, RE_PACKAGE_SUBDIRS, '' );
				if ( contains( group, '/_tools/' ) ) {
					continue;
				}
				if ( !out[ group ] ) {
					out[ group ] = [];
				}
				if ( !contains( out[ group ], commit ) ) {
					out[ group ].push( commit );
				}
			}
		}
	}
	return out;
}


// MAIN //

/**
* Generates a Markdown formatted changelog for a specified package.
*
* @param {string} pkg - package name
* @throws {TypeError} must provide a string
* @throws {Error} must provide a valid package name
* @returns {string} changelog contents
*
* @example
* var changelog = generate( 'utils/curry' );
* // returns '...'
*
* @example
* var changelog = generate( 'stats/base/dists' );
* // returns '...'
*
* @example
* var changelog = generate( 'proxy' );
* // returns '...'
*/
function generate( pkg ) {
	var isNamespacePkg;
	var releaseCommits;
	var bySubpackage;
	var standalone;
	var unreleased;
	var releases;
	var pkgNames;
	var commits;
	var summary;
	var date;
	var href;
	var name;
	var out;
	var i;
	var j;

	if ( !isString( pkg ) ) {
		throw new TypeError( format( 'invalid argument. Must provide a string. Value: `%s`.', pkg ) );
	}
	if ( pkg === '' ) {
		// Case: root package
		isNamespacePkg = true;
		standalone = '@stdlib/stdlib';
		releases = objectEntries( npmReleases( standalone ) );
	} else {
		// Case: all other packages
		isNamespacePkg = contains( STDLIB_NAMESPACE_PKGS, '@stdlib/' + pkg );
		standalone = '@stdlib/' + replace( pkg, '/', '-' );
		releases = objectEntries( npmReleases( standalone ) );
	}

	out = '';
	out += '# CHANGELOG';
	out += '\n';
	out += '\n';
	out += '> Package changelog.';

	commits = parseCommits( pkg );
	if ( commits.length === 0 ) {
		throw new Error( 'invalid argument. Unable to parse commits for package: `'+pkg+'`.' );
	}

	// Filter out all commits which only affect internal tooling:
	commits = filter( commits, isNotInternalTooling );

	// Group commits by release:
	commits = groupBy( commits, indicator );
	if ( isNamespacePkg ) {
		out += heading( 'Unreleased', 2 );
		bySubpackage = groupBySubPackage( commits.unreleased, pkg );
		pkgNames = objectKeys( bySubpackage ).sort();
		out += heading( 'Packages', 3 );
		for ( i = 0; i < pkgNames.length; i++ ) {
			name = pkgNames[ i ];
			unreleased = releaseSummary( bySubpackage[ name ], true, true );
			if ( unreleased ) {
				out += '<details>\n\n';
				name = ( ( pkg ) ? '/' + pkg : pkg ) + ( ( name ) ? '/' + name : '' );
				href = STDLIB_REPO_NODE_PATH + '/%40stdlib' + name;
				out += '<summary>';
				out += '<a href="' + href + '">@stdlib' + name + '</a>';
				out += '</summary>\n\n';
				out += decrementHeaders( unreleased );
				out += '</details>\n\n';
			}
		}
		out += formatContributors( commits.unreleased );
		out += formatCommits( commits.unreleased );
	} else {
		unreleased = releaseSummary( commits.unreleased );
		if ( unreleased ) {
			out += heading( 'Unreleased', 2 );
			out += unreleased;
		}
	}
	if ( isNamespacePkg ) {
		for ( i = releases.length-1; i >= 0; i-- ) {
			releaseCommits = commits[ releases[ i ][ 0 ] ];
			if ( !releaseCommits ) {
				continue;
			}
			date = new Date( releases[ i ][ 1 ] ).toISOString().slice( 0, 10 );
			out += '## ' + releases[ i ][ 0 ] + ' (' + date + ')';
			out += '\n';
			out += '\n';
			bySubpackage = groupBySubPackage( releaseCommits, pkg );
			pkgNames = objectKeys( bySubpackage ).sort();
			out += heading( 'Packages', 3 );
			for ( j = 0; j < pkgNames.length; j++ ) {
				name = pkgNames[ j ];
				summary = releaseSummary( bySubpackage[ name ], true, true );
				if ( !summary ) {
					continue;
				}
				name = pkg + ( ( name ) ? '/' + name : '' );
				href = STDLIB_REPO_NODE_PATH + '/%40stdlib/' + name;
				out += '<details>\n\n';
				out += '<summary>';
				out += '<a href="' + href + '">@stdlib/' + name + '</a>';
				out += '</summary>\n\n';
				out += decrementHeaders( summary );
				out += '</details>';
			}
			out += formatContributors( releaseCommits );
			out += formatCommits( releaseCommits );
		}
	} else {
		for ( i = releases.length-1; i >= 0; i-- ) {
			summary = releaseSummary( commits[ releases[ i ][ 0 ] ] );
			if ( !summary ) {
				continue;
			}
			date = new Date( releases[ i ][ 1 ] ).toISOString().slice( 0, 10 );
			out += '## ' + releases[ i ][ 0 ] + ' (' + date + ')';
			out += '\n';
			out += '\n';
			out += summary;
		}
	}
	out = replace( out, RE_EXTRANEOUS_NEWLINES, '\n\n' );
	return out;

	/**
	* Indicator function indicating which release a commit belongs to.
	*
	* @private
	* @param {Object} commit - commit object
	* @returns {string} release indicator
	*/
	function indicator( commit ) {
		var version;
		var date;
		var i;

		// Walk the releases in reverse chronological order:
		for ( i = releases.length-1; i >= 0; i-- ) {
			version = releases[ i ][ 0 ];
			date = releases[ i ][ 1 ];
			if ( new Date( commit.date ) <= new Date( date ) ) {
				return version;
			}
		}
		return 'unreleased';
	}

	/**
	* Tests whether a commit only affects internal tooling, i.e., files located in the `lib/node_modules/@stdlib/_tools/` directory.
	*
	* @private
	* @param {Object} commit - commit object
	* @returns {boolean} boolean indicating whether a commit is not only touching internal tooling
	*/
	function isNotInternalTooling( commit ) {
		var files;
		var bool;
		var i;

		files = commit.files;
		bool = false;
		for ( i = 0; i < files.length; i++ ) {
			if ( files[ i ].indexOf( 'lib/node_modules/@stdlib/_tools/' ) === -1 ) {
				bool = true;
				break;
			}
		}
		return bool;
	}
}


// EXPORTS //

module.exports = generate;
