/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var logger = require( 'debug' );
var groupBy = require( '@stdlib/utils/group-by' );
var filter = require( '@stdlib/array/base/filter' );
var trim = require( '@stdlib/string/trim' );
var map = require( '@stdlib/utils/map' );
var formatCommitFactory = require( './format_commit_factory.js' );
var formatClosedIssues = require( './format_closed_issues.js' );
var formatContributors = require( './format_contributors.js' );
var formatCommits = require( './format_commits.js' );
var heading = require( './heading.js' );


// VARIABLES //

var debug = logger( 'changelog:generate:release-summary' );
var STDLIB_GITHUB_URL = 'https://github.com/stdlib-js/stdlib/commit';


// FUNCTIONS //

/**
* Collects all field elements from a list of commits.
*
* @private
* @param {ObjectArray} commits - commit objects
* @param {string} field - field to collect
* @returns {ObjectArray} field elements
*/
function collectField( commits, field ) {
	var out;
	var i;
	var j;

	out = [];
	for ( i = 0; i < commits.length; i++ ) {
		for ( j = 0; j < commits[ i ][ field ].length; j++ ) {
			out.push( commits[ i ][ field ][ j ] );
		}
	}
	return out;
}

/**
* Formats a breaking change.
*
* @private
* @param {Object} note - note object
* @returns {string} changelog entry
*
* @example
* var note = {
*     'title': 'BREAKING CHANGE',
*     'text': 'beep',
*     'hash': 'abcdef1234567890'
* };
* var out = formatBreakingChange( note );
* // returns '-   [`abcdef1`](https://github.com/stdlib-js/stdlib/commit/abcdef1234567890): beep'
*/
function formatBreakingChange( note ) {
	var parts = note.text.split( '\n' );
	var hash = trim( note.hash );
	var out = '-   [`';
	out += hash.substring( 0, 7 );
	out += '`](';
	out += STDLIB_GITHUB_URL;
	out += '/';
	out += hash;
	out += '): ';
	out += parts[ 0 ];
	if ( parts.length > 1 ) {
		out +=' \n\n';
		out += '    -   ';
		out += parts.slice( 1 ).join( '\n    ' );
		out += '\n';
	}
	return out;
}


// MAIN //

/**
* Generates a release summary.
*
* @private
* @param {ObjectArray} commits - commit objects
* @param {boolean} excludeCommits - boolean indicating whether to exclude commit details
* @param {boolean} excludeContributors - boolean indicating whether to exclude a list of contributors
* @returns {string} summary
*/
function releaseSummary( commits, excludeCommits, excludeContributors ) {
	var breakingChanges;
	var groupedFormat;
	var closedIssues;
	var mentions;
	var grouped;
	var notes;
	var out;

	if ( !commits || !commits.length ) {
		return '';
	}
	grouped = groupBy( commits, groupByType );
	notes = collectField( commits, 'notes' );
	breakingChanges = filter( notes, isBreakingChange );
	out = '';

	groupedFormat = formatCommitFactory( false, false );
	if ( grouped.feat ) {
		out += '\n\n<section class="features">\n\n';
		out += heading( 'Features', 3 );
		out += map( grouped.feat, groupedFormat ).join( '\n' );
		out += '\n\n</section>\n\n';
		out += '<!-- /.features -->\n\n';
	}
	if ( grouped.fix ) {
		out += '\n\n<section class="bug-fixes">\n\n';
		out += heading( 'Bug Fixes', 3 );
		out += map( grouped.fix, groupedFormat ).join( '\n' );
		out += '\n\n</section>\n\n';
		out += '<!-- /.bug-fixes -->\n\n';
	}
	if ( grouped.perf ) {
		out += '\n\n<section class="performance">\n\n';
		out += heading( 'Performance', 3 );
		out += map( grouped.perf, groupedFormat ).join( '\n' );
		out += '\n\n</section>\n\n';
		out += '<!-- /.performance -->\n\n';
	}
	if ( grouped.revert ) {
		out += '\n\n<section class="reverts">\n\n';
		out += heading( 'Reverts', 3 );
		out += map( grouped.revert, groupedFormat ).join( '\n' );
		out += '\n\n</section>\n\n';
		out += '<!-- /.reverts -->\n\n';
	}
	if ( grouped.deprecate ) {
		out += '\n\n<section class="deprecations">\n\n';
		out += heading( 'Deprecations', 3 );
		out += map( grouped.deprecate, groupedFormat ).join( '\n' );
		out += '\n\n</section>\n\n';
		out += '<!-- /.deprecations -->\n\n';
	}
	if ( breakingChanges && breakingChanges.length > 0 ) {
		debug( 'Found %d breaking changes...', breakingChanges.length );
		out += '\n\n<section class="breaking-changes">\n\n';
		out += heading( 'BREAKING CHANGES', 3 );
		out += map( breakingChanges, formatBreakingChange ).join( '\n' );
		out += '\n\n</section>\n\n';
		out += '<!-- /.breaking-changes -->\n\n';
	}

	mentions = collectField( commits, 'mentions' );
	closedIssues = filter( mentions, isClosingIssue );
	closedIssues.sort( sortByIssueNumber );
	if ( closedIssues && closedIssues.length > 0 ) {
		out += formatClosedIssues( closedIssues );
	}
	if ( !excludeCommits ) {
		out += formatCommits( commits );
	}
	if ( !excludeContributors ) {
		out += formatContributors( commits );
	}
	return out;

	/**
	* Groups commits by type.
	*
	* @private
	* @param {Object} commit - commit object
	* @returns {(string|null)} group key
	*/
	function groupByType( commit ) {
		return commit.type;
	}

	/**
	* Tests whether a note is a breaking change.
	*
	* @private
	* @param {Object} note - note object
	* @returns {boolean} boolean indicating whether a note is a breaking change
	*/
	function isBreakingChange( note ) {
		return note.title === 'BREAKING CHANGE';
	}

	/**
	* Tests whether a mention references closing an issue.
	*
	* @private
	* @param {Object} mention - mention object
	* @returns {boolean} boolean indicating whether a mention references closing an issue
	*/
	function isClosingIssue( mention ) {
		return mention.action === 'Closes' || mention.action === 'Fixes' || mention.action === 'Resolves';
	}

	/**
	* Sorts issue mentions by issue number.
	*
	* @private
	* @param {Object} a - first mention
	* @param {Object} b - second mention
	* @returns {number} difference in issue numbers
	*/
	function sortByIssueNumber( a, b ) {
		return a.ref - b.ref;
	}
}


// EXPORTS //

module.exports = releaseSummary;
