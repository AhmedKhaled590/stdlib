/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var fs = require( 'fs' );
var path = require( 'path' );
var logger = require( 'debug' );
var computeVendorModules = require('./vendor_modules.js');

var objectKeys = require( '@stdlib/utils/keys' );
var pkgNames = require( '@stdlib/_tools/pkgs/names').sync
var extractSource = require( '@stdlib/_tools/esm/extract-source' );
var removeHeaderFileList = require( '@stdlib/_tools/licenses/remove-header-file-list' ).sync;
var createVendorBundles = require( '@stdlib/_tools/esm/create-vendor-bundles' );
var waterfall = require( '@stdlib/utils/async/series-waterfall' );
var transformCommonjs = require( '@stdlib/_tools/esm/transform-commonjs-file-list' ).sync;


// VARIABLES //

var debug = logger( 'esm:bundle' );


// MAIN //

function build( roots, baseOutputDirectory, options, clbk ) {
	var manifest;

	waterfall([
		function( next ) {
			debug('Extracting source');
			manifest = extractSource( roots, baseOutputDirectory );

			next();
		},
		function( next ) {
			var i;

			debug('Removing license headers');
			for (i = 0; i < manifest.length; i++) {
				removeHeaderFileList( manifest[i].files, /\* @license Apache-2\.0/ );
			}

			next();
		},
		function( next ) {
			var vendorDeps;
			var vendorPath;

			debug('Vendoring external dependencies');
			vendorDeps = computeVendorModules( manifest );

			vendorPath = path.join( baseOutputDirectory, '@stdlib', 'vendor' );

			createVendorBundles( vendorPath, vendorDeps, next );
		},
		function( next ) {
			var i;
			var pkg;

			debug('Bundling package sources');
			for ( i = 0; i < manifest.length; i++ ) {
				pkg = manifest[i];

				transformCommonjs( pkg.files );
			}
		}
	], function ( err, result ) {
		debug('Done');
		clbk( err, result );
	});






	/*
	var packageJSONPath = require.resolve(path.join(root, 'package.json'));

	var packageJSON = require(packageJSONPath);

	var entryPoint = Object.hasOwnProperty( packageJSON, 'browser' ) ? packageJSON.browser : packageJSON.main;

	var entry = require.resolve(path.join(root, entryPoint));


	var inputOptions = {
		input: entry,
		plugins: [
			rollupPluginResolve({
				browser: true,
				jail: root
			}),
			rollupPluginCommonJS({
				esmExternals: true,
				requireReturnsDefault: true,
				//ignore: function (path) {
					//return /^@stdlib\//.test(path);
				//},
			})
		]
	};

	var outputOptions = {
	};



	// Pass a dummy regex and override its test method to permit only the very first instance of a Stdlib Apache 2.0 license.
	var captureSingleStdlibApacheLicense = false;
	var oneStdlibApacheRegex = /@license Apache-2.0/;
	oneStdlibApacheRegex.test = function (str) {
		// Preserve potentially all licenses
		if (!/@license\b/.test(str)) return false;

		// Permit only one Stdlib Authors Apache-2.0 license
		if (/@license Apache-2.0/.test(str) && /The Stdlib Authors/.test(str)) {
			if (captureSingleStdlibApacheLicense) return false;
			captureSingleStdlibApacheLicense = true;
		}

		return true;
	};

	return rollup.rollup(inputOptions).then(bundle => {
		return bundle.generate(outputOptions);
	}).then(output => {
		return output.output[0].code;
	}).then(code => {
		return minify(code, {
			'compress': true,
			'mangle': true,
			'format': {
				'comments': oneStdlibApacheRegex
			}
		});
	}).then(output => {
		return output.code
	}).catch(error => {
		console.error(error)
		process.exit(1);
	});
	*/
}


// EXPORTS //

module.exports = build;
