/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var path = require( 'path' );
var debug = require( 'debug' );
var mkdirp = require( 'mkdirp' ).sync;
var forEachAsync = require( '@stdlib/utils/async/for-each' );
var writeFile = require( '@stdlib/fs/write-file' ).sync;
var createBundle = require( './create_bundle.js' );


// VARIABLES //

var logger = debug('esm:create-vendor-bundles');

var QUALIFIED_REQUIRE_REGEX = /.\/./;


// FUNCTIONS //

/**
 * Create a handler for completed bundling.
 *
 * @private
 * @param {String} outputDirectory - directory path to which output is written
 * @param {String} moduleName - external module to be vendored
 * @param {Callback} next - continuation callback
 * @returns {Function} handler callback
 */
function onBundledFactory( outputDirectory, moduleName, next ) {
	/** Handler for completed bundling.
	 *
	 * @private
	 * @param {Error|undefined} err - error instance
	 * @param {Object} code - object containing bundled code
	 * @returns {void}
	 */
	function onBundled( err, code ) {
		var isQualifiedRequire;
		var bundleOutputPath;
		var dirName;

		if ( err ) {
			return next( err );
		}

		isQualifiedRequire = QUALIFIED_REQUIRE_REGEX.test( moduleName );

		if ( isQualifiedRequire ) {
			dirName = path.join( outputDirectory, path.dirname( moduleName ) );

			logger( 'Creating subdirectory %s for qualified require in %s', dirName, moduleName );
			mkdirp(dirName);
		}

		bundleOutputPath = path.join( outputDirectory, moduleName + '.js' );

		logger( 'Writing module %s to %s.', moduleName, bundleOutputPath );
		err = writeFile( bundleOutputPath, code );

		if ( err instanceof Error) {
			return next( err );
		}

		next();
	}

	return onBundled;
}

/**
 * Create a function for bundling a module.
 *
 * @private
 * @param {String} outputDirectory - path to output destination
 * @returns {Function} function for performing bundling
 */
function onModuleFactory( outputDirectory ) {
	/**
	 * Bundle a module.
	 *
	 * @private
	 * @param {String} moduleName - a string representing the external module name
	 * @param {Number} i - module iteration index
	 * @param {Callback} next - async continuation.
	 */
	function onModule( moduleName, i, next ) {
		var onBundled;

		logger( 'Bundling vendor module: %s', moduleName );

		onBundled = onBundledFactory( outputDirectory, moduleName, next );

		createBundle( moduleName, onBundled );
	}

	return onModule;
}

/**
 * Create vendored bundles for a list of modules.
 *
 * @private
 * @param {Array} moduleList - list of modules to be bundled
 * @param {String} outputDirectory - path to output destination
 * @param {Callback} clbk - callback executed on completion
 */
function createVendorBundles( moduleList, outputDirectory, clbk ) {
	var onModule;
	var opts;

	logger( 'Ensuring existence of output directory %s', outputDirectory );
	mkdirp( outputDirectory );

	onModule = onModuleFactory( outputDirectory );

	opts = {
		'limit': 3
	};

	forEachAsync( moduleList, opts, onModule, clbk );
}


// EXPORTS //

module.exports = createVendorBundles;
