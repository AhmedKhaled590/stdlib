/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var fs = require( 'fs' );
var debug = require( 'debug' );
var rollup = require('rollup');
var rollupPluginVirtual = require( '@rollup/plugin-virtual' );
var rollupPluginResolve = require( '@rollup/plugin-node-resolve' ).default;
var rollupPluginCommonjs = require( '@rollup/plugin-commonjs' );
var minify = require( 'terser' ).minify;


// VARIABLES //

var logger = debug('esm:create-vendor-bundles');

// See for context: https://github.com/d3/d3-interpolate/issues/58
var D3_WARNING = /Circular dependency.*d3-interpolate/;


// FUNCTIONS //

/**
 * Silence Rollup warnings resulting from circular D3 dependencies.
 *
 * @private
 * @param {string} message - candidate message to be silenced
 * @returns {string|undefined} original message or undefined, if silenced
 */
function swallowD3Warning( message ) {
	if ( D3_WARNING.test(message) ) {
		return;
	}

	return message;
}

/**
 * Minify a bundled output.
 *
 * @private
 * @param {Object} bundle - output of bundling
 * @returns {Object} minified result
 */
function minifyBundle( bundle ) {
	var code = bundle.output[0].code;

	return minify(code, {
		'compress': true,
		'mangle': true
	});
}

/**
 * Create a vendored bundle for an external module.
 *
 * @param {string} moduleName - name of node module to be vendored
 * @param {Callback} clbk - callback executed on completion
 * @returns {void}
 */
function createBundle( moduleName, clbk ) {
	var outputOptions;
	var licenseHeader;
	var inputOptions;
	var src;

	logger( 'Creating vendor bundle for %s', moduleName );

	switch (moduleName) {
	case 'events':
	case 'buffer':
	case 'vdom-to-html':
	case 'virtual-dom/h':
	case 'readable-stream':
	case 'debug':
		src = 'import mod from \'' + moduleName + '\';\nexport default mod;';
		break;

	case 'process':
		src = 'import mod from \'process/browser\';export default mod;';
		break;

	case 'os':
	case 'path':
		src = 'import mod from \'' + moduleName + '-browserify\';\nexport default mod;';
		break;

	case 'http':
		src = 'import mod from \'stream-http\';\nexport default mod;';
		break;

	case 'd3-format':
	case 'd3-scale':
	case 'd3-time-format':
	case 'd3-shape':
		// These packages do not export default, so we must strictly re-export
		src = 'export * from \'' + moduleName + '\';';
		break;

	case 'fs':
	case 'child_process':
		// Empty
		src = 'export default {};';
		break;

	default:
		return clbk( new Error( 'Unhandled vendor module \'' + moduleName + '\'. Implementation must be individually handled for every vendor module.' ) );
	}

	switch (moduleName) {
	case 'd3-format':
	case 'd3-scale':
	case 'd3-time-format':
	case 'd3-shape':
	case 'events':
	case 'vdom-to-html':
	case 'debug':
	case 'process':
		licenseHeader = fs.readFileSync( require.resolve( moduleName + '/LICENSE' ), 'utf8' ).replace(/^/mg, '// ');
		break;

	case 'readable-stream':
		licenseHeader = fs.readFileSync( require.resolve( moduleName + '/LICENSE' ), 'utf8' ).replace(/^/mg, '// ');

		// Prepend this to the source
		licenseHeader += '\nimport Buffer from \'./buffer.js\';';
		licenseHeader += '\nimport process from \'./process.js\';';
		break;

	case 'fs':
	case 'child_process':
		licenseHeader = '';
		break;

	case 'virtual-dom/h':
		// Drop '/h' from the package to retrieve the license
		licenseHeader = fs.readFileSync( require.resolve( 'virtual-dom/LICENSE' ), 'utf8' ).replace(/^/mg, '// ');
		break;

	case 'buffer':
		// License text is already commented
		licenseHeader = fs.readFileSync( require.resolve( moduleName + '/LICENSE' ), 'utf8' );
		break;

	case 'os':
	case 'path':
		// Package is called '*-browserify'
		licenseHeader = fs.readFileSync( require.resolve( moduleName + '-browserify/LICENSE' ), 'utf8' ).replace(/^/mg, '// ');
		break;

	case 'http':
		// Based on the choice of https://github.com/browserify/browserify/blob/7b14fb1c92b31e4f469d71d97e0c370d65f2e058/lib/builtins.js#L13
		licenseHeader = fs.readFileSync( require.resolve( 'stream-http/LICENSE' ), 'utf8' ).replace(/^/mg, '// ');
		break;

	default:
		return clbk( new Error( 'Unhandled vendor module \'' + moduleName + '\'. Licensing must be individually handled for every vendor module.' ) );
	}

	inputOptions = {
		'input': 'virtual.js',
		'plugins': [
			rollupPluginVirtual({
				'virtual.js': src
			}),
			rollupPluginResolve({
				'preferBuiltins': false,
				'browser': true
			}),
			rollupPluginCommonjs()
		],
		'onwarn': swallowD3Warning
	};

	outputOptions = {
	};

	/**
	 * Perform bundling.
	 *
	 * @private
	 * @param {Object} bundler - configured bundler instance
	 * @returns {Object} bundler output
	 */
	function generateBundle( bundler ) {
		return bundler.generate( outputOptions );
	}

	/**
	 * Handle an error encountered during the process.
	 *
	 * @private
	 * @param {Error|null} error - bundler error
	 */
	function handleError( error ) {
		clbk( error, null );
	}

	/**
	 * Handle the bundled result, passing the bundler output to the callback.
	 *
	 * @private
	 * @param {Object} output - bundler output
	 * @returns {void}
	 */
	function handleBundled( output ) {
		clbk( null, [ licenseHeader, output.code ].join( '\n' ) );
	}

	rollup.rollup(inputOptions)
		.then( generateBundle )
		.then( minifyBundle )
		.then( handleBundled )
		.catch( handleError );
}


// EXPORTS //

module.exports = createBundle;
