/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var path = require( 'path' );
var minify = require( 'terser' ).minify;
var mkdirp = require( 'mkdirp' ).sync;
var logger = require( 'debug' );

var transformVendorRequires = require( '@stdlib/_tools/esm/transform-vendor-requires-file-list' ).sync;
var removeHeaderFileList = require( '@stdlib/_tools/licenses/remove-header-file-list' ).sync;
var createVendorBundles = require( '@stdlib/_tools/esm/create-vendor-bundles' );
var importsToRelative = require( '@stdlib/_tools/esm/transform-imports-to-relative-file-list' ).sync;
var transformCommonjs = require( '@stdlib/_tools/esm/transform-commonjs-file-list' ).sync;
var extractSource = require( '@stdlib/_tools/esm/extract-source' );
var insertHeader = require( '@stdlib/_tools/licenses/insert-header-file-list' );
var forEachAsync = require( '@stdlib/utils/async/for-each' );
var writeFile = require( '@stdlib/fs/write-file' ).sync;
var waterfall = require( '@stdlib/utils/async/series-waterfall' );
var readFile = require( '@stdlib/fs/read-file' ).sync;
var bundle = require( '@stdlib/_tools/esm/bundle' );

var computeVendorModules = require( './vendor_modules.js' );


// VARIABLES //

var debug = logger( 'esm:create-dist' );

var BUNDLER_OPTS = { };

var MINIFY_OPTS = {
	'compress': false,
	'mangle': {
		'toplevel': true
	}
};

var APACHE_LICENSE_HEADER = '// This file is a part of stdlib. License is Apache-2.0: http://www.apache.org/licenses/LICENSE-2.0';


// MAIN //

/**
 * Build a list of packages to ESM modules.
 *
 * @param {Array} pkgList - list of packages to be bundled
 * @param {string} outputDir - output directory path
 * @param {Object} options - additional configuration options
 * @param {Callback} clbk - callback executed on completion
 * @returns {void}
 */
function build( pkgList, outputDir, options, clbk ) {
	var manifest;

	/**
	 * Extract sources into a build directory.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function extractAllSources( next ) {
		debug('Extracting source');
		manifest = extractSource( pkgList, outputDir );

		next();
	}

	/**
	 * Remove license headers from source files in build directory.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function removeLicenseHeaders( next ) {
		var i;

		debug('Removing license headers');
		for ( i = 0; i < manifest.length; i++) {
			removeHeaderFileList( manifest[i].files, /\* @license Apache-2\.0/ );
		}

		next();
	}

	/**
	 * Create vendor modules for any external dependencies.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function vendorExternalDeps( next ) {
		var vendorDeps;
		var vendorPath;

		debug( 'Vendoring external dependencies' );
		vendorDeps = computeVendorModules( manifest );

		vendorPath = path.join( outputDir, '@stdlib', 'vendor' );

		createVendorBundles( vendorPath, vendorDeps, next );
	}

	/**
	 * Rewrite vendored requires to use bundled vendor modules.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function rewriteVendorRequires( next ) {
		var i;

		debug( 'Rewriting vendor requires' );
		for (i = 0; i < manifest.length; i++) {
			transformVendorRequires( manifest[i].files );
		}

		next();
	}

	/**
	 * Transform require statements into import statements.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function transformCommonjsToESM( next ) {
		var pkg;
		var i;

		debug( 'Transforming CJS to ESM' );
		for ( i = 0; i < manifest.length; i++ ) {
			pkg = manifest[i];

			transformCommonjs( pkg.files );
		}

		next();
	}

	/**
	 * Bundle package sources.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function bundleSources( next ) {
		debug( 'Bundling sources' );

		/**
		 * Bundle a package.
		 *
		 * @private
		 * @param {string} pkg - package name
		 * @param {Callback} nextPkg - callback executed on completion
		 * @returns {void}
		 */
		function bundlePackage( pkg, nextPkg ) {
			var pkgOutputDirectory = path.dirname( pkg.output );

			/**
			 * Callback on successful bundling.
			 *
			 * @private
			 * @param {Error|null} error - error instance
			 * @param {string} code - bundled code
			 * @returns {void}
			 */
			function onBundle( error, code ) {
				if ( error instanceof Error ) {
					return nextPkg( error );
				}

				mkdirp( pkgOutputDirectory );
				writeFile( pkg.output, code );

				nextPkg();
			}

			bundle( pkg.entry, BUNDLER_OPTS, onBundle );
		}

		forEachAsync( manifest, bundlePackage, next );
	}

	/**
	 * Transform @stdlib imports into paths relative to each package.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function transformImportPaths( next ) {
		var outputs;
		var opts;
		var i;

		debug( 'Transforming import paths to relative' );

		opts = {
			'validatePath': /^@stdlib\//
		};

		outputs = [];
		for (i = 0; i < manifest.length; i++) {
			outputs.push( manifest[i].output );
		}

		importsToRelative( outputs, outputDir, opts );

		next();
	}

	/**
	 * Minify the bundled modules.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function minifyOutputs( next ) {
		debug( 'Minifying' );

		/**
		 * Minify the package.
		 *
		 * @private
		 * @param {string} pkg - package path
		 * @param {Callback} nextPkg - callback executed on completion
		 * @returns {void}
		 */
		function minifyPackage( pkg, nextPkg ) {
			var sourceMapFilename;
			var source;
			var opts;

			source = readFile( pkg.output, 'utf8' );
			sourceMapFilename = path.basename( pkg.output ) + '.map';

			opts = Object.assign({}, MINIFY_OPTS, {
				'sourceMap': {
					'url': sourceMapFilename
				}
			});

			/**
			 * Handle successful minification.
			 *
			 * @private
			 * @param {Object} output - object containing result of minification
			 * @returns {void}
			 */
			function onMinify( output ) {
				writeFile( pkg.output, output.code );
				writeFile( pkg.output + '.map', output.map );

				nextPkg();
			}

			minify( source, opts )
				.then(onMinify)
				.catch(nextPkg);
		}

		forEachAsync( manifest, minifyPackage, next );
	}

	/**
	 * Add license headers to the bundled modules.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function addLicenseHeaders( next ) {
		var outputs;
		var i;

		debug( 'Adding license headers' );

		outputs = [];
		for ( i = 0; i < manifest.length; i++) {
			outputs.push( manifest[i].output );
		}

		insertHeader( outputs, APACHE_LICENSE_HEADER, next );
	}

	/**
	 * Callback executed on completion of workflow.
	 *
	 * @private
	 * @param {Callback} error - callback executed on completion
	 * @returns {void}
	 */
	function onComplete( error ) {
		if ( error ) {
			debug('Failed');
			debug( error );
		} else {
			debug('Done');
		}
		clbk( error );
	}

	waterfall([
		extractAllSources,
		removeLicenseHeaders,
		vendorExternalDeps,
		rewriteVendorRequires,
		transformCommonjsToESM,
		bundleSources,
		transformImportPaths,
		minifyOutputs,
		addLicenseHeaders
	], onComplete);
}


// EXPORTS //

module.exports = build;
