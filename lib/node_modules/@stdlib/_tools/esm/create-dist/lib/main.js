/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var path = require( 'path' );
var minify = require( 'terser' ).minify;
var mkdirp = require( 'mkdirp' ).sync;
var logger = require( 'debug' );

var keyByRight = require( '@stdlib/utils/key-by-right' );
var browserDeps = require( '@stdlib/_tools/pkgs/browser-deps' ).sync;
var browserEntryPoints = require( '@stdlib/_tools/pkgs/browser-entry-points' ).sync;
var transformVendorRequires = require( '@stdlib/_tools/esm/transform-vendor-requires-file-list' ).sync;
var removeHeaderFileList = require( '@stdlib/_tools/licenses/remove-header-file-list' );
var createVendorBundles = require( '@stdlib/_tools/esm/create-vendor-bundles' );
var importsToRelative = require( '@stdlib/_tools/esm/transform-imports-to-relative-file-list' ).sync;
var transformCommonjs = require( '@stdlib/_tools/esm/transform-commonjs-file-list' ).sync;
var insertHeader = require( '@stdlib/_tools/licenses/insert-header-file-list' );
var forEachAsync = require( '@stdlib/utils/async/for-each' );
var writeFile = require( '@stdlib/fs/write-file' ).sync;
var waterfall = require( '@stdlib/utils/async/series-waterfall' );
var readFile = require( '@stdlib/fs/read-file' ).sync;
var bundle = require( '@stdlib/_tools/esm/bundle' );

var computeVendorModules = require( './vendor_modules.js' );
var copyBrowserSources = require( './copy_sources.js' );
var debugPage = require( './debug_page' );


// VARIABLES //

var JS_EXTENSION = /\.js$/;

var debug = logger( 'esm:create-dist' );

var BUNDLER_OPTS = { };

var MINIFY_OPTS = {
	'compress': false,
	'mangle': {
		'toplevel': true
	}
};

var APACHE_LICENSE_HEADER = '// This file is a part of stdlib. License is Apache-2.0: http://www.apache.org/licenses/LICENSE-2.0';


// FUNCTIONS //

/**
 * Get the pkg field of an object.
 *
 * @private
 * @param {Object} value - an object in a list
 * @returns {String} name identifier of package
 */
function getPkg( value ) {
	return value.pkg;
}


// MAIN //

/**
 * Build a list of packages to ESM modules.
 *
 * @param {Array} pkgs - list of packages to be bundled
 * @param {string} outputDir - output directory path
 * @param {Object} options - additional configuration options
 * @param {Callback} clbk - callback executed on completion
 * @returns {void}
 */
function build( pkgs, outputDir, options, clbk ) {
	var copiedJSFiles;
	var entriesByPkg;
	var bundledFiles;
	var buildTmpDir;
	var copiedFiles;
	var entries;
	var deps;

	deps = browserDeps( pkgs );
	entries = browserEntryPoints( pkgs );

	entriesByPkg = keyByRight( entries, getPkg );

	buildTmpDir = path.join( outputDir, '_buildtmp' );

	bundledFiles = [];

	waterfall([
		copySources,
		removeLicenseHeaders,
		vendorExternalDeps,
		rewriteVendorRequires,
		transformCommonjsToESM,
		bundleSources,
		transformImportPaths,
		minifyOutputs,
		addLicenseHeaders,
		createDebugPage
	], onComplete);

	/**
	 * Callback executed on completion of workflow.
	 *
	 * @private
	 * @param {Callback} error - callback executed on completion
	 * @returns {void}
	 */
	function onComplete( error ) {
		if ( error ) {
			debug('Failed');
			debug( error );
		} else {
			debug('Done');
		}
		clbk( error );
	}

	/**
	 * Extract sources into a build directory.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function copySources( next ) {
		debug( 'Copying browser sources' );
		copyBrowserSources( deps, buildTmpDir, onCopiedSources );

		/**
		 * Process the results of copying sources.
		 *
		 * @private
		 * @param {Error|null} err - error, if encountered during copying
		 * @param {Array} files - list of written files
		 * @returns {void}
		 */
		function onCopiedSources( err, files ) {
			var i;

			if ( err instanceof Error ) {
				next( err );
				return;
			}

			copiedFiles = files;
			copiedJSFiles = [];

			for ( i = 0; i < files.length; i++ ) {
				if ( JS_EXTENSION.test( files[ i ] ) ) {
					copiedJSFiles.push( files[ i ] );
				}
			}

			next( null );
		}
	}

	/**
	 * Remove license headers from source files in build directory.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function removeLicenseHeaders( next ) {
		debug('Removing license headers');

		removeHeaderFileList( copiedFiles, /\* @license Apache-2\.0/, next );
	}

	/**
	 * Create vendor modules for any external dependencies.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function vendorExternalDeps( next ) {
		var vendorDeps;
		var vendorPath;

		debug( 'Vendoring external dependencies' );
		vendorDeps = computeVendorModules( deps );

		vendorDeps = vendorDeps.concat([
			'buffer',
			'events',
			'fs',
			'path',
			'http',
			'child_process',
			'os'
		]);

		vendorPath = path.join( outputDir, '@stdlib', 'vendor' );

		createVendorBundles( vendorDeps, vendorPath, next );
	}

	/**
	 * Rewrite vendored requires to use bundled vendor modules.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function rewriteVendorRequires( next ) {
		debug( 'Rewriting vendor requires' );
		transformVendorRequires( copiedJSFiles );

		next();
	}

	/**
	 * Decide whether to permit named imports in vendor requires when transforming to ESM imports.
	 *
	 * @private
	 * @param {String} module - module name found in require()
	 * @returns {Boolean} whether named imports are permissible
	 */
	function permitNamedImport( module ) {
		return /d3-/.test( module );
	}

	/**
	 * Transform require statements into import statements.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function transformCommonjsToESM( next ) {
		var opts;

		debug( 'Transforming CJS to ESM' );

		opts = {
			'permitNamedImport': permitNamedImport
		};

		transformCommonjs( copiedJSFiles, opts );

		next();
	}

	/**
	 * Construct a function to perform bundling.
	 *
	 * @private
	 * @param {String} output - path to output location
	 * @param {Error|null} clbk - callback to be called on completion of bundling
	 * @returns {Function} bundler function
	 */
	function onBundleFactory( output, clbk ) {
		/**
		 * Function called on completed bundling.
		 *
		 * @private
		 * @param {Error|null} error - bundler error
		 * @param {String} code - code output
		 * @returns {void}
		 */
		function onBundle( error, code ) {
			var pkgOutputDirectory = path.dirname( output );

			mkdirp( pkgOutputDirectory );
			writeFile( output, code );

			bundledFiles.push( output );

			clbk( error );
		}

		return onBundle;
	}

	/**
	 * Bundle package sources.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function bundleSources( next ) {
		var opts;

		debug( 'Bundling sources' );

		opts = {
			'limit': 8
		};

		forEachAsync( pkgs, opts, bundlePackage, next );

		/**
		 * Bundle a package.
		 *
		 * @private
		 * @param {string} pkg - package name
		 * @param {Number} i - package iteration index
		 * @param {Callback} nextPkg - callback executed on completion
		 * @returns {void}
		 */
		function bundlePackage( pkg, i, nextPkg ) {
			var onBundle;
			var output;
			var entry;
			var input;
			var rel;

			debug( 'Bundling package: %s (%d of %d)', pkg, i + 1, pkgs.length );

			entry = entriesByPkg[ pkg ];
			rel = path.relative( entry.dir, entry.entries[ 0 ] );

			input = path.resolve( buildTmpDir, entry.pkg, rel );
			output = path.resolve( outputDir, entry.pkg + '.js' );

			onBundle = onBundleFactory( output, nextPkg );

			bundle( input, BUNDLER_OPTS, onBundle );
		}
	}

	/**
	 * Transform @stdlib imports into paths relative to each package.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function transformImportPaths( next ) {
		var opts;

		debug( 'Transforming import paths to relative' );

		opts = {
			'validatePath': /^@stdlib\//
		};

		importsToRelative( bundledFiles, outputDir, opts );

		next();
	}

	/**
	 * Minify the bundled modules.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function minifyOutputs( next ) {
		debug( 'Minifying' );

		/**
		 * Minify the package.
		 *
		 * @private
		 * @param {string} file - file path to input
		 * @param {Callback} nextPkg - callback executed on completion
		 * @returns {void}
		 */
		function minifyPackage( file, nextPkg ) {
			var sourceMapFilename;
			var source;
			var opts;

			source = readFile( file, 'utf8' );
			sourceMapFilename = path.basename( file ) + '.map';

			opts = Object.assign({}, MINIFY_OPTS, {
				'sourceMap': {
					'url': sourceMapFilename
				}
			});

			/**
			 * Handle successful minification.
			 *
			 * @private
			 * @param {Object} output - object containing result of minification
			 * @returns {void}
			 */
			function onMinify( output ) {
				writeFile( file, output.code );
				writeFile( file + '.map', output.map );

				nextPkg();
			}

			minify( source, opts )
				.then(onMinify)
				.catch(nextPkg);
		}

		forEachAsync( bundledFiles, minifyPackage, next );
	}

	/**
	 * Add license headers to the bundled modules.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function addLicenseHeaders( next ) {
		debug( 'Adding license headers' );

		insertHeader( bundledFiles, APACHE_LICENSE_HEADER, next );
	}

	/**
	 * Create an HTML page for debugging module resolution.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function createDebugPage( next ) {
		var outputFile;

		debug( 'Writing debug page' );

		outputFile = path.join( __dirname, '..', 'examples', 'dist', 'test.html' );

		debugPage( deps, outputFile, next );
	}
}


// EXPORTS //

module.exports = build;
