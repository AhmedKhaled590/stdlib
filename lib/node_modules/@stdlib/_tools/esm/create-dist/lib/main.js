/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var fs = require( 'fs' );
var path = require( 'path' );
var minify = require( 'terser' ).minify;
var mkdirp = require( 'mkdirp' ).sync;
var logger = require( 'debug' );
var rimraf = require( 'rimraf' );

var browserDeps = require( '@stdlib/_tools/pkgs/browser-deps' ).sync;
var transformVendorRequires = require( '@stdlib/_tools/esm/transform-vendor-requires-file-list' ).sync;
var removeHeaderFileList = require( '@stdlib/_tools/licenses/remove-header-file-list' );
var createVendorBundles = require( '@stdlib/_tools/esm/create-vendor-bundles' );
var transformProcessFileList = require( '@stdlib/_tools/esm/transform-process-file-list' ).sync;
var importsToRelative = require( '@stdlib/_tools/esm/transform-imports-to-relative-file-list' ).sync;
var transformCommonjs = require( '@stdlib/_tools/esm/transform-commonjs-file-list' ).sync;
var insertHeader = require( '@stdlib/_tools/licenses/insert-header-file-list' );
var forEachAsync = require( '@stdlib/utils/async/for-each' );
var writeFile = require( '@stdlib/fs/write-file' ).sync;
var waterfall = require( '@stdlib/utils/async/series-waterfall' );
var readFile = require( '@stdlib/fs/read-file' ).sync;
var bundle = require( '@stdlib/_tools/esm/bundle' );

var computeVendorModules = require( './vendor_modules.js' );
var copyBrowserSources = require( './copy_sources.js' );
var debugPage = require( './debug_page' );


// VARIABLES //

var JS_EXTENSION = /\.js$/;

var debug = logger( 'esm:create-dist' );

var APACHE_LICENSE_HEADER = '// This file is a part of stdlib. License is Apache-2.0: http://www.apache.org/licenses/LICENSE-2.0';


// MAIN //

/**
 * Build a list of packages to ESM modules.
 *
 * @param {Array} pkgs - list of packages to be bundled
 * @param {string} outputDir - output directory path
 * @param {Object} options - additional configuration options
 * @param {Callback} clbk - callback executed on completion
 * @returns {void}
 */
function build( pkgs, outputDir, options, clbk ) {
	var copiedJSFiles;
	var bundledFiles;
	var buildTmpDir;
	var copiedFiles;
	var preserveTmp;
	var deps;

	deps = browserDeps( pkgs );

	buildTmpDir = path.join( outputDir, '_buildtmp' );

	if ( fs.existsSync( buildTmpDir ) ) {
		clbk( new Error( 'temporary build directory \'' + path.resolve( buildTmpDir ) + '\' already exists. Exiting.' ) );
		return;
	}

	preserveTmp = ( typeof options === 'undefined' ) ? false : !!options.preserveTmp;

	bundledFiles = [];

	waterfall([
		copySources,
		removeLicenseHeaders,
		vendorExternalDeps,
		rewriteVendorRequires,
		transformCommonjsToESM,
		transformProcess,
		bundleSources,
		transformImportPaths,
		minifyOutputs,
		addLicenseHeaders,
		createDebugPage,
		cleanup
	], onComplete);

	/**
	 * Callback executed on completion of workflow.
	 *
	 * @private
	 * @param {Callback} error - callback executed on completion
	 * @returns {void}
	 */
	function onComplete( error ) {
		if ( error ) {
			debug('Failed');
			debug( error );
		} else {
			debug('Done');
		}
		clbk( error );
	}

	/**
	 * Extract sources into a build directory.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function copySources( next ) {
		debug( 'Copying browser sources' );
		copyBrowserSources( deps, buildTmpDir, onCopiedSources );

		/**
		 * Process the results of copying sources.
		 *
		 * @private
		 * @param {Error|null} err - error, if encountered during copying
		 * @param {Array} files - list of written files
		 * @returns {void}
		 */
		function onCopiedSources( err, files ) {
			var i;

			if ( err instanceof Error ) {
				next( err );
				return;
			}

			copiedFiles = files;
			copiedJSFiles = [];

			for ( i = 0; i < files.length; i++ ) {
				if ( JS_EXTENSION.test( files[ i ] ) ) {
					copiedJSFiles.push( files[ i ] );
				}
			}

			next( null );
		}
	}

	/**
	 * Remove license headers from source files in build directory.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function removeLicenseHeaders( next ) {
		debug('Removing license headers');

		removeHeaderFileList( copiedFiles, /\* @license Apache-2\.0/, next );
	}

	/**
	 * Create vendor modules for any external dependencies.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function vendorExternalDeps( next ) {
		var vendorDeps;
		var vendorPath;

		debug( 'Vendoring external dependencies' );
		vendorDeps = computeVendorModules( deps );

		// Node builtins are not detected by browser-deps
		vendorDeps = vendorDeps.concat([
			'buffer',
			'events',
			'fs',
			'path',
			'http',
			'child_process',
			'os',
			'process',
			'module'
		]);

		debug( 'Vendoring modules: %s', vendorDeps.join( ', ' ) );

		vendorPath = path.join( outputDir, '@stdlib', 'vendor' );

		createVendorBundles( vendorDeps, vendorPath, next );
	}

	/**
	 * Rewrite vendored requires to use bundled vendor modules.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function rewriteVendorRequires( next ) {
		debug( 'Rewriting vendor requires' );
		transformVendorRequires( copiedJSFiles );

		next();
	}

	/**
	 * Rewrite vendored requires to use bundled vendor modules.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function transformProcess( next ) {
		debug( 'Rewriting vendor requires' );
		transformProcessFileList( copiedJSFiles );

		next();
	}

	/**
	 * Decide whether to permit named imports in vendor requires when transforming to ESM imports.
	 *
	 * @private
	 * @param {String} module - module name found in require()
	 * @returns {Boolean} whether named imports are permissible
	 */
	function permitNamedImport( module ) {
		return /d3-/.test( module );
	}

	/**
	 * Transform require statements into import statements.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function transformCommonjsToESM( next ) {
		var opts;

		debug( 'Transforming CJS to ESM' );

		opts = {
			'permitNamedImport': permitNamedImport
		};

		transformCommonjs( copiedJSFiles, opts );

		next();
	}

	/**
	 * Construct a function to perform bundling.
	 *
	 * @private
	 * @param {String} outputFile - path to output location
	 * @param {Error|null} clbk - callback to be called on completion of bundling
	 * @returns {Function} bundler function
	 */
	function onBundleFactory( outputFile, clbk ) {
		/**
		 * Function called on completed bundling.
		 *
		 * @private
		 * @param {Error|null} error - bundler error
		 * @param {String} output - bundler output
		 * @returns {void}
		 */
		function onBundle( error, output ) {
			var pkgOutputDirectory;
			var code;
			var map;

			code = output[0].code;
			map = output[0].map.toString();

			pkgOutputDirectory = path.dirname( outputFile );

			mkdirp( pkgOutputDirectory );
			writeFile( outputFile, code );
			writeFile( outputFile + '.map', map );

			bundledFiles.push( outputFile );

			clbk( error );
		}

		return onBundle;
	}

	/**
	 * Transfrom sourcemap paths from build-tmp-relative to @stdlib-relative.
	 *
	 * @param {String} relativeSourcePath - path of source relative to cwd
	 * @returns {String} transformed path
	 */
	function sourcemapPathTransform( relativeSourcePath ) {
		var src = path.resolve( process.cwd(), relativeSourcePath );
		return path.relative( buildTmpDir, src );
	}

	/**
	 * Bundle package sources.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function bundleSources( next ) {
		var opts;

		debug( 'Bundling sources' );

		opts = {
			'limit': 3
		};

		forEachAsync( pkgs, opts, bundlePackage, next );

		/**
		 * Bundle a package.
		 *
		 * @private
		 * @param {string} pkg - package name
		 * @param {Number} i - package iteration index
		 * @param {Callback} nextPkg - callback executed on completion
		 * @returns {void}
		 */
		function bundlePackage( pkg, i, nextPkg ) {
			var onBundle;
			var output;
			var input;
			var entry;
			var opts;

			debug( 'Bundling package: %s (%d of %d)', pkg, i + 1, pkgs.length );

			entry = 'lib/index.js';

			input = path.resolve( buildTmpDir, pkg, entry );
			output = path.resolve( outputDir, pkg + '.js' );

			onBundle = onBundleFactory( output, nextPkg );

			opts = {
				'sourcemapPathTransform': sourcemapPathTransform
			};

			bundle( input, opts, onBundle );
		}
	}

	/**
	 * Transform @stdlib imports into paths relative to each package.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function transformImportPaths( next ) {
		var opts;

		debug( 'Transforming import paths to relative' );

		opts = {
			'validatePath': /^@stdlib\//
		};

		importsToRelative( bundledFiles, outputDir, opts );

		next();
	}

	/**
	 * Minify the bundled modules.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function minifyOutputs( next ) {
		var opts;

		debug( 'Minifying' );

		/**
		 * Minify the package.
		 *
		 * @private
		 * @param {string} file - file path to input
		 * @param {Callback} nextPkg - callback executed on completion
		 * @returns {void}
		 */
		function minifyPackage( file, nextPkg ) {
			var inputSourceMapContent;
			var outputSourceMap;
			var fullMinify;
			var source;
			var opts;

			debug( 'Minifying %s', path.relative( outputDir, file ) );

			source = readFile( file, 'utf8' );
			outputSourceMap = path.basename( file ) + '.map';
			inputSourceMapContent = readFile( file + '.map', 'utf8' );

			fullMinify = !/datasets\/(cmudict|spam-assassin)/.test( file );

			opts = {
				'compress': fullMinify,
				'mangle': {
					'toplevel': fullMinify
				},
				'sourceMap': {
					'url': outputSourceMap,
					'content': inputSourceMapContent
				}
			};

			/**
			 * Handle successful minification.
			 *
			 * @private
			 * @param {Object} output - object containing result of minification
			 * @returns {void}
			 */
			function onMinify( output ) {
				writeFile( file, output.code );
				writeFile( file + '.map', output.map );

				nextPkg();
			}

			minify( source, opts )
				.then(onMinify)
				.catch(nextPkg);
		}

		opts = {
			'limit': 2
		};

		forEachAsync( bundledFiles, opts, minifyPackage, next );
	}

	/**
	 * Add license headers to the bundled modules.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function addLicenseHeaders( next ) {
		debug( 'Adding license headers' );

		insertHeader( bundledFiles, APACHE_LICENSE_HEADER, next );
	}

	/**
	 * Create an HTML page for debugging module resolution.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function createDebugPage( next ) {
		var outputFile;

		debug( 'Writing debug page' );

		outputFile = path.join( __dirname, '..', 'examples', 'dist', 'test.html' );

		debugPage( deps, outputFile, next );
	}

	/**
	 * Clean up the temporary build directory.
	 *
	 * @private
	 * @param {Callback} next - callback executed on completion
	 * @returns {void}
	 */
	function cleanup( next ) {
		if ( preserveTmp ) {
			next();
			return;
		}

		debug( 'Removing temporary build directory' );

		// We ensured this did not exist before starting this process, so it's a reasonably safe cleanup process. This would not apply if we did not first check.

		rimraf( buildTmpDir, next );
	}
}


// EXPORTS //

module.exports = build;
