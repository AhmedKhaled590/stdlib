/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var computeVendorModules = require( './vendor_modules.js' );
var minify = require( 'terser' ).minify;
var mkdirp = require( 'mkdirp' ).sync;
var logger = require( 'debug' );
var path = require( 'path' );
var fs = require( 'fs' );

var transformImportsToRelative = require( '@stdlib/_tools/esm/transform-imports-to-relative-file-list' ).sync;
var transformVendorRequires = require( '@stdlib/_tools/esm/transform-vendor-requires-file-list' ).sync;
var removeHeaderFileList = require( '@stdlib/_tools/licenses/remove-header-file-list' ).sync;
var createVendorBundles = require( '@stdlib/_tools/esm/create-vendor-bundles' );
var transformCommonjs = require( '@stdlib/_tools/esm/transform-commonjs-file-list' ).sync;
var extractSource = require( '@stdlib/_tools/esm/extract-source' );
var insertHeader = require( '@stdlib/_tools/licenses/insert-header-file-list' );
var forEachAsync = require( '@stdlib/utils/async/for-each' );
var objectKeys = require( '@stdlib/utils/keys' );
var writeFile = require( '@stdlib/fs/write-file' ).sync;
var waterfall = require( '@stdlib/utils/async/series-waterfall' );
var readFile = require( '@stdlib/fs/read-file' ).sync;
var pkgNames = require( '@stdlib/_tools/pkgs/names').sync
var bundle = require( '@stdlib/_tools/esm/bundle' );


// VARIABLES //

var debug = logger( 'esm:create-dist' );

var BUNDLER_OPTS = { };

var MINIFY_OPTS = {
	'compress': true,
	'mangle': true,
};

var APACHE_LICENSE_HEADER = '// This file is a part of stdlib. License is Apache-2.0: http://www.apache.org/licenses/LICENSE-2.0';



// MAIN //

function build( pkgList, outputDir, options, clbk ) {
	var manifest;

	waterfall([
		function( next ) {
			debug('Extracting source');
			manifest = extractSource( pkgList, outputDir );

			next();
		},
		function( next ) {
			var i;

			debug('Removing license headers');
			for (i = 0; i < manifest.length; i++) {
				removeHeaderFileList( manifest[i].files, /\* @license Apache-2\.0/ );
			}

			next();
		},
		function( next ) {
			var vendorDeps;
			var vendorPath;

			debug( 'Vendoring external dependencies' );
			vendorDeps = computeVendorModules( manifest );

			vendorPath = path.join( outputDir, '@stdlib', 'vendor' );

			createVendorBundles( vendorPath, vendorDeps, next );
		},
		function( next ) {
			var i;

			debug( 'Rewriting vendor requires' );
			for (i = 0; i < manifest.length; i++) {
				transformVendorRequires( manifest[i].files );
			}

			next();
		},
		function( next ) {
			var i;
			var pkg;

			debug( 'Transforming CJS to ESM' );
			for ( i = 0; i < manifest.length; i++ ) {
				pkg = manifest[i];

				transformCommonjs( pkg.files );
			}

			next();
		},
		function( next ) {
			var pkg;

			debug( 'Bundling sources' );

			forEachAsync( manifest, function( pkg, nextPkg ) {
				var pkgOutputDir = path.dirname( pkg.output );

				bundle( pkg.entry, BUNDLER_OPTS, function( err, code ) {
					if ( err instanceof Error ) {
						return nextPkg( err );
					}

					mkdirp( pkgOutputDir );
					writeFile( pkg.output, code );

					nextPkg();
				});
			}, next );
		},
		function( next ) {
			var opts;
			var pkg;
			var i;

			debug( 'Transforming import paths to relative' );

			opts = {
				'validatePath': /^@stdlib\//
			};

			var outputs = manifest.map(function( pkg ) { return pkg.output; });

			transformImportsToRelative( outputs, outputDir, opts );

			next();
		},
		function( next ) {
			debug( 'Minifying' );

			forEachAsync( manifest, function ( pkg, nextPkg ) {
				var source;

				source = readFile( pkg.output, 'utf8' );
				var sourceMapFilename = path.basename( pkg.output ) + '.map';

				var opts = Object.assign({}, MINIFY_OPTS, {
					'sourceMap': {
						'url': sourceMapFilename
					}
				});

				minify( source, opts ).then(function ( output ) {
					writeFile( pkg.output, output.code );
					writeFile( pkg.output + '.map', output.map );

					nextPkg();
				}).catch(function( err ) {
					nextPkg( null, err );
				});
			}, next );
		},
		function( next ) {
			debug( 'Adding license headers' );

			var outputs = manifest.map(function( pkg ) { return pkg.output; });

			insertHeader( outputs, APACHE_LICENSE_HEADER, next );
		}
	], function ( err, result ) {
		if ( err ) {
			debug('Failed');
		} else {
			debug('Done');
		}
		clbk( err, result );
	});
}


// EXPORTS //

module.exports = build;
