/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var computeVendorModules = require( './vendor_modules.js' );
var minify = require( 'terser' ).minify;
var mkdirp = require( 'mkdirp' ).sync;
var logger = require( 'debug' );
var path = require( 'path' );
var fs = require( 'fs' );

var rewriteVendorRequires = require( '@stdlib/_tools/esm/rewrite-vendor-requires-file-list' ).sync;
var removeHeaderFileList = require( '@stdlib/_tools/licenses/remove-header-file-list' ).sync;
var createVendorBundles = require( '@stdlib/_tools/esm/create-vendor-bundles' );
var transformCommonjs = require( '@stdlib/_tools/esm/transform-commonjs-file-list' ).sync;
var extractSource = require( '@stdlib/_tools/esm/extract-source' );
var forEachAsync = require( '@stdlib/utils/async/for-each' );
var objectKeys = require( '@stdlib/utils/keys' );
var writeFile = require( '@stdlib/fs/write-file' ).sync;
var waterfall = require( '@stdlib/utils/async/series-waterfall' );
var readFile = require( '@stdlib/fs/read-file' ).sync;
var pkgNames = require( '@stdlib/_tools/pkgs/names').sync
var bundle = require( '@stdlib/_tools/esm/bundle' );


// VARIABLES //

var debug = logger( 'esm:create-dist' );

var ROLLUP_OPTS = { };

var TERSER_OPTS = {
	'compress': true,
	'mangle': true,
};


// MAIN //

function build( roots, baseOutputDirectory, options, clbk ) {
	var manifest;

	waterfall([
		function( next ) {
			debug('Extracting source');
			manifest = extractSource( roots, baseOutputDirectory );

			next();
		},
		function( next ) {
			var i;

			debug('Removing license headers');
			for (i = 0; i < manifest.length; i++) {
				removeHeaderFileList( manifest[i].files, /\* @license Apache-2\.0/ );
			}

			next();
		},
		function( next ) {
			var vendorDeps;
			var vendorPath;

			debug('Vendoring external dependencies');
			vendorDeps = computeVendorModules( manifest );

			vendorPath = path.join( baseOutputDirectory, '@stdlib', 'vendor' );

			createVendorBundles( vendorPath, vendorDeps, next );
		},
		function( next ) {
			var i;

			debug('Rewriting vendor requires');
			for (i = 0; i < manifest.length; i++) {
				rewriteVendorRequires( manifest[i].files );
			}

			next();
		},
		function( next ) {
			var i;
			var pkg;

			debug('Transforming CJS to ESM');
			for ( i = 0; i < manifest.length; i++ ) {
				pkg = manifest[i];

				transformCommonjs( pkg.files );
			}

			next();
		},
		function( next ) {
			var pkg;
			var i;

			debug('Bundling sources');

			forEachAsync( manifest, function( pkg, nextPkg ) {
				var outputDir = path.dirname( pkg.output );

				bundle( pkg.entry, ROLLUP_OPTS, function( err, code ) {
					if ( err instanceof Error ) {
						return nextPkg( err );
					}

					mkdirp( outputDir );
					writeFile( pkg.output, code );

					nextPkg();
				});
			}, next );
		},
		function( next ) {
			var i;

			debug('Minifying');

			forEachAsync( manifest, function ( pkg, nextPkg ) {
				var source;

				source = readFile( pkg.output, 'utf8' );

				minify( source, TERSER_OPTS ).then(function ( output ) {
					writeFile( pkg.output, output.code );

					nextPkg();
				}).catch(function( err ) {
					nextPkg( null, err );
				});
			}, next );
		}
	], function ( err, result ) {
		debug('Done');
		clbk( err, result );
	});
}


// EXPORTS //

module.exports = build;
